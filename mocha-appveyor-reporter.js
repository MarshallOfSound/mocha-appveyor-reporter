var util = require('util'),
    Base = require('mocha').reporters.Base;

function AppVeyorReporter(runner) {
  Base.call(this, runner);
  var request = require('request-json'),
    deasync = require('deasync'),
    endpoint = process.env.APPVEYOR_API_URL,
    log = console.log.bind(console),
    error = console.error.bind(console),
    warn = console.warn.bind(console),
    logEntries = [],
    client = endpoint ? request.createClient(endpoint) : null;

  if(!endpoint) {
    warn("APPVEYOR_API_URL environment variable is not set, will not report to appveyor.");
  }

  /**
   * Takes a test result and maps it to the output format that AppVeyor accepts.
   * @param test Result generated by mocha.
   * @returns {{testName: string, testFramework: string, fileName: string, outcome: string, durationMilliseconds: Number, StdOut: string, StdErr: string}}
   */
  var mapTest = function(test) {
    var stdout = "";
    var stderr = "";
    logEntries.forEach(function (data) {
      var msg = util.format.apply(util, data.msg);
      if (data.type === 'out') {
        stdout = stdout + msg + '\n';
      } else {
        stderr = stderr + msg + '\n';
      }
    });
    return {
      testName: test.fullTitle(),
      testFramework: 'Mocha',
      fileName: test.file,
      outcome: test.state === "passed" ? "Passed" : null,
      durationMilliseconds: test.duration,
      StdOut: stdout,
      StdErr: stderr
    };
  };

  /**
   * Sends test to AppVeyor synchronously, will timeout after 5000ms and report any errors encountered.
   * @param test {Object} Test generated from {@link mapTest} to send.
   */
  var sendTest = function(test) {
    if(client) {
      var complete;
      var body = null;
      var rsp = null;
      var err = null;
      client.post('api/tests', test, function(e, b, r) {
        err = e;
        body = b;
        rsp = r;
        complete = true;
      });
      // Timeout web request.  This should only happen in unusual circumstances where AppVeyor does not respond.
      setTimeout(function () {
        error = new Error("Timeout waiting for response from AppVeyor after 5000ms.");
      }, 5000);
      // Blocks until successful web request.  This is not ideal, but prevents test from completing before proceeding
      // to next test or mocha exiting.
      deasync.loopWhile(function(){
        return !complete;
      });
      if(err) {
        error("Error returned from posting test result to AppVeyor for '%s'. Response: %s, Body: %s. Request Body: \n",
          test.testName, rsp, body, test);
      }
    }
  };

  /**
   * @param type {String} The type of message being logged (either 'out' for stdout or anything else for stderr).
   * @param original {Function} Function to be wrapped.
   * @returns {Function} A function that wraps the given original function with behavior that records messages to
   * a separate array.
   */
  var handleConsole = function(type, original) {
    return function() {
      var args = Array.prototype.slice.call(arguments);
      if(original.apply && typeof original.apply === 'function') {
        original.apply(original, arguments);
      }
      logEntries.push({ type: type, msg: args });
    }
  };

  runner.on('test', function (test) {
    // trap console so we can record stdout/stderr to appveyor.
    logEntries = [];
    console.log = handleConsole("out", log);
    console.warn = handleConsole("warn", warn);
    console.error = handleConsole("err", error);
  });

  runner.on('test end', function(test) {
    // reset console implementations to original implementation.
    console.log = log;
    console.warn = warn;
    console.error = error;
  });

  runner.on('pass', function(mochaTest){
    var test = mapTest(mochaTest);
    sendTest(test);
  });

  runner.on('pending', function(mochaTest) {
    var test = mapTest(mochaTest);
    test.outcome = 'Ignored';
    sendTest(test);
  });

  runner.on('fail', function(mochaTest, err) {
    var test = mapTest(mochaTest);
    test.outcome = 'Failed';
    test.ErrorMessage = err.message;
    test.ErrorStackTrace = err.stack;
    sendTest(test);
  });
}

util.inherits(AppVeyorReporter, Base);

module.exports = AppVeyorReporter;
